{"version":3,"file":"shablon.es.js","names":["obj"],"sources":["../src/state.js","../src/template.js","../src/router.js"],"sourcesContent":["let activeWatcher;\n\nlet flushQueue = new Set();\nlet allWatchers = new Map();\nlet toRemove = [];\nlet cleanTimeoutId;\n\nlet idSym = Symbol();\nlet parentSym = Symbol();\nlet pathsResetedSym = Symbol();\nlet childrenSym = Symbol();\nlet pathsSubsSym = Symbol();\nlet unwatchedSym = Symbol();\nlet onRemoveSym = Symbol();\n\n/**\n * Watch registers a callback function that fires on initialization and\n * every time any of its evaluated `store` reactive properties change.\n *\n * It returns a \"watcher\" object that could be used to `unwatch()` the registered listener.\n *\n * Optionally also accepts a second callback function that is excluded from the evaluated\n * store props tracking and instead is invoked only when `trackedFunc` is called\n * (could be used as a \"track-only\" watch pattern).\n *\n * Simple example:\n *\n * ```js\n * const data = store({ count: 0 })\n *\n * const sub = watch(() => console.log(data.count))\n *\n * data.count++ // triggers watch update\n *\n * sub.unwatch()\n *\n * data.count++ // doesn't trigger watch update\n * ```\n *\n * \"Track-only\" example:\n *\n * ```js\n * const data = store({\n *     a: 0,\n *     b: 0,\n *     c: 0,\n * })\n *\n * // watch only \"a\" and \"b\" props\n * watch(() => [\n *    data.a,\n *    data.b,\n * ], () => {\n *     console.log(data.a)\n *     console.log(data.b)\n *     console.log(data.c)\n * })\n *\n * data.a++ // trigger watch update\n * data.b++ // trigger watch update\n * data.c++ // doesn't trigger watch update\n * ```\n *\n * @param {Function} trackedFunc\n * @param {Function} [optUntrackedFunc]\n * @return {{unwatch:Function, last:any, run:Function}}\n */\nexport function watch(trackedFunc, optUntrackedFunc) {\n    let watcher = {\n        [idSym]: \"_\" + Math.random(),\n    }\n\n    allWatchers.set(watcher[idSym], watcher);\n\n    watcher.run = () => {\n        let oldActiveWatcher;\n\n        // nested watcher -> register previous watcher as parent\n        if (activeWatcher) {\n            oldActiveWatcher = activeWatcher\n            watcher[parentSym] = activeWatcher[idSym];\n\n            // store immediate children references for quicker cleanup\n            activeWatcher[childrenSym] = activeWatcher[childrenSym] || [];\n            activeWatcher[childrenSym].push(watcher[idSym]);\n        }\n\n        activeWatcher = watcher;\n        activeWatcher[pathsResetedSym] = false;\n        const result = trackedFunc();\n\n        if (optUntrackedFunc) {\n            activeWatcher = null;\n            optUntrackedFunc(result);\n        }\n\n        // restore original ref (if any)\n        activeWatcher = oldActiveWatcher;\n    };\n\n    watcher.unwatch = function () {\n        watcher[unwatchedSym] = 1;\n\n        toRemove.push(watcher[idSym]);\n\n        if (cleanTimeoutId) {\n            clearTimeout(cleanTimeoutId);\n        }\n\n        // note: debounced and executed as separate task to minimize blocking unmount rendering\n        cleanTimeoutId = setTimeout(() => {\n            for (let id of toRemove) {\n                removeWatcher(id);\n            }\n\n            toRemove = [];\n            cleanTimeoutId = null;\n        }, 50);\n    };\n\n    watcher.run();\n\n    return watcher;\n}\n\nfunction removeWatcher(id) {\n    let w = allWatchers.get(id);\n\n    w?.[onRemoveSym]?.();\n\n    if (w?.[childrenSym]) {\n        for (let childId of w[childrenSym]) {\n            removeWatcher(childId);\n        }\n        w[parentSym] = null;\n        w[childrenSym] = null;\n    }\n\n    if (w?.[pathsSubsSym]) {\n        for (let subset of w[pathsSubsSym]) {\n            if (subset.has(id)) {\n                subset.delete(id);\n            }\n        }\n        w[pathsSubsSym] = null;\n    }\n\n    allWatchers.delete(id);\n}\n\n// -------------------------------------------------------------------\n\n/**\n * Creates a new deeply reactive store object that triggers `watch`\n * update on change of a specific watched store property.\n *\n * Example:\n *\n * ```js\n * const data = store({ count: 0, name: \"test\" })\n *\n * watch(() => console.log(data.count)) // should fire twice: 0 (initial), 1 (on increment)\n *\n * data.count++\n * ```\n *\n * Getters are also supported out of the box and they are invoked every\n * time when any of their dependencies change.\n * If a getter is used in a reactive function, its resulting value is cached,\n * aka. if the final value hasn't changed it will not trigger an unnecessary reactive update.\n *\n * Multiple changes from one or many stores are also automatically batched in a microtask.\n *\n * @param  {Object} obj\n * @return {Object} Proxied object.\n */\nexport function store(obj) {\n    let pathWatcherIds = new Map();\n\n    return createProxy(obj, pathWatcherIds);\n}\n\nfunction createProxy(obj, pathWatcherIds) {\n    // extract props info to identify getters\n    let descriptors =\n        typeof obj == \"object\" && !Array.isArray(obj)\n            ? Object.getOwnPropertyDescriptors(obj)\n            : {};\n\n    let handler = {\n        get(obj, prop, target) {\n            if (prop === \"__raw\") {\n                return obj;\n            }\n\n            // getter?\n            let getterProp;\n            if (descriptors[prop]?.get) {\n                // if not invoked inside a watch function, call the original\n                // getter to ensure that an up-to-date value is computed\n                if (!activeWatcher) {\n                    return descriptors[prop]?.get?.call(obj);\n                }\n\n                getterProp = prop;\n\n                // replace with an internal \"@prop\" property so that\n                // reactive statements can be cached\n                prop = \"@\" + prop;\n            }\n\n            const propVal = obj[prop]\n\n            // directly return symbols and functions (pop, push, etc.)\n            if (typeof prop == \"symbol\" || typeof propVal == \"function\") {\n                return propVal;\n            }\n\n            // wrap child object or array as sub store\n            if (\n                propVal !== null && typeof propVal == \"object\" &&\n                !propVal[parentSym] &&\n                !isExcludedInstance(propVal)\n            ) {\n                propVal[parentSym] = [obj, prop];\n                obj[prop] = createProxy(propVal, pathWatcherIds);\n            }\n\n            // register watch subscriber (if any)\n            if (activeWatcher) {\n                let currentPath = getPath(obj, prop);\n                let activeWatcherId = activeWatcher[idSym];\n\n                activeWatcher[pathsSubsSym] = activeWatcher[pathsSubsSym] || new Set();\n\n                // If this is a rerun of the watcher function, resets any previous\n                // tracking paths because after this new run some of the old\n                // dependencies may no longer be reachable/evaluatable.\n                //\n                // For example, in the below code:\n                //\n                // ```js\n                // const data = store({ a: 0, b: 0, c: 0 })\n                //\n                // watch(() => {\n                //     if (data.a > 0) {\n                //         data.b\n                //     } else {\n                //         data.c\n                //     }\n                // })\n                // ```\n                //\n                // initially ONLY \"a\" and \"c\" should be trackable because \"b\"\n                // is not reachable (aka. its getter is never invoked).\n                //\n                // If we increment `a++`, then in the new run  ONLY \"a\" and \"b\" should be trackable\n                // because this time \"c\" is not reachable (aka. its getter is never invoked)\n                // and its previous tracking should be removed for this watcher.\n                //\n                // Note: The below code works because it reuses the same \"subs\" reference as in pathWatcherIds\n                //       and this is intentional to avoid unnecessary iterations.\n                if (!activeWatcher[pathsResetedSym]) {\n                    activeWatcher[pathsSubsSym].forEach((subs) => {\n                        subs.delete(activeWatcherId)\n                    })\n                    activeWatcher[pathsResetedSym] = true;\n                }\n\n                let subs = pathWatcherIds.get(currentPath);\n                if (!subs) {\n                    subs = new Set();\n                    pathWatcherIds.set(currentPath, subs);\n                }\n                subs.add(activeWatcherId);\n\n                activeWatcher[pathsSubsSym].add(subs);\n\n                // register a child watcher to update the custom getter prop replacement\n                // (should be removed automatically with the removal of the parent watcher)\n                if (\n                    getterProp &&\n                    !descriptors[getterProp]._watchers?.has(activeWatcherId)\n                ) {\n                    descriptors[getterProp]._watchers =\n                        descriptors[getterProp]._watchers || new Set();\n                    descriptors[getterProp]._watchers.add(activeWatcherId);\n\n                    let getFunc = descriptors[getterProp].get.bind(obj);\n\n                    let getWatcher = watch(() => (target[prop] = getFunc()));\n\n                    getWatcher[onRemoveSym] = () => {\n                        descriptors[getterProp]?.watchers?.delete(watcherId);\n                    };\n                }\n            }\n\n            return obj[prop];\n        },\n        set(obj, prop, value) {\n            if (typeof prop == \"symbol\") {\n                obj[prop] = value;\n                return true;\n            }\n\n            let oldValue = obj[prop];\n            obj[prop] = value;\n\n            // trigger only on value change\n            // (exclude length since the old value would have been already changed on access)\n            if (value != oldValue || prop === \"length\") {\n                callWatchers(obj, prop, pathWatcherIds);\n            }\n\n            return true;\n        },\n        deleteProperty(obj, prop) {\n            if (typeof prop != \"symbol\") {\n                callWatchers(obj, prop, pathWatcherIds);\n\n                let currentPath = getPath(obj, prop);\n                if (pathWatcherIds.has(currentPath)) {\n                    pathWatcherIds.delete(currentPath);\n                }\n            }\n\n            delete obj[prop];\n\n            return true;\n        },\n    };\n\n    return new Proxy(obj, handler);\n}\n\nfunction getPath(obj, prop) {\n    let currentPath = prop;\n\n    let parentData = obj?.[parentSym];\n    while (parentData) {\n        currentPath = parentData[1] + \".\" + currentPath;\n        parentData = parentData[0][parentSym];\n    }\n\n    return currentPath;\n}\n\nfunction isExcludedInstance(val) {\n    return (\n        (val instanceof Date) ||\n        (val instanceof Set) ||\n        (val instanceof Map) ||\n        (val instanceof WeakRef) ||\n        (val instanceof WeakMap) ||\n        (val instanceof WeakSet)\n    )\n}\n\nfunction callWatchers(obj, prop, pathWatcherIds) {\n    let currentPath = getPath(obj, prop);\n\n    let watcherIds = pathWatcherIds.get(currentPath);\n\n    if (!watcherIds) {\n        return true;\n    }\n\n    for (let id of watcherIds) {\n        flushQueue.add(id);\n\n        if (flushQueue.size != 1) {\n            continue;\n        }\n\n        queueMicrotask(() => {\n            let watcher;\n            for (let runId of flushQueue) {\n                watcher = allWatchers.get(runId);\n                if (!watcher || watcher[unwatchedSym]) {\n                    continue;\n                }\n\n                // if both parent and child watcher exists,\n                // execute only the parent because the child\n                // watchers will be invoked automatically\n                if (watcher[parentSym] && flushQueue.has(watcher[parentSym])) {\n                    continue;\n                }\n\n                watcher.run();\n            }\n\n            flushQueue.clear();\n        });\n    }\n}\n","import { watch } from \"./state.js\";\n\n/**\n * Proxy object for creating and returning a new HTML element in the format `t.[tag](attrs, ...children)`.\n *\n * For example:\n *\n * ```js\n * t.div({ className: \"test-div\" },\n *     t.span({ textContent: \"child1\"}),\n *     t.span({ textContent: \"child2\"}),\n * )\n * ```\n *\n * `attrs` is an object where the keys are:\n * - valid element's [JS property](https://developer.mozilla.org/en-US/docs/Web/API/Element#instance_properties)\n *   _(note that some HTML attribute names are different from their JS property equivalent, e.g. `class` vs `className`, `for` vs `htmlFor`, etc.)_\n * - regular or custom HTML attribute if it has `html-` prefix _(it is stripped from the final attribute)_, e.g. `html-data-name`\n *\n * The attributes value could be a plain JS value or reactive function that returns such value _(e.g. `() => data.count`)_.\n *\n * `children` is an optional list of child elements that could be:\n * - plain text (inserted as `TextNode`)\n * - single tag\n * - array of tags\n * - reactive function that returns any of the above\n *\n * Each constructed tag has 3 additional optional lifecycle attributes:\n * - `onmount: func` - optional callback called when the element is inserted in the DOM\n * - `onunmount: func` - optional callback called when the element is removed from the DOM\n * - `rid: any` - \"replacement id\" is an identifier based on which we can decide whether to reuse the element or not during rerendering (e.g. on list change); the value could be anything comparable with `==`\n *\n * @param  {string} tagName\n * @param  {Object} attrs\n * @param  {...Node} children\n * @return {HTMLElement}\n */\nexport const t = new Proxy(\n    {},\n    {\n        get(_, prop) {\n            return function () {\n                initMutationObserver();\n\n                return tag.call(undefined, prop, ...arguments);\n            };\n        },\n    },\n);\n\n// -------------------------------------------------------------------\n\nlet isMutationObserverInited = false;\nfunction initMutationObserver() {\n    if (isMutationObserverInited) {\n        return;\n    }\n\n    isMutationObserverInited = true;\n\n    function recursiveObserveCall(method, nodes) {\n        for (let n of nodes) {\n            if (n[method]) {\n                n[method](n);\n            }\n            if (n.childNodes) {\n                recursiveObserveCall(method, n.childNodes);\n            }\n        }\n    }\n\n    const observer = new MutationObserver((mutations) => {\n        for (let m of mutations) {\n            recursiveObserveCall(\"onmount\", m.addedNodes);\n            recursiveObserveCall(\"onunmount\", m.removedNodes);\n        }\n    });\n\n    observer.observe(document, { childList: true, subtree: true });\n}\n\nlet watchFuncsSym = Symbol();\nlet registeredWatchersSym = Symbol();\nlet isMountedSym = Symbol();\nlet cleanupFuncsSym = Symbol();\n\nfunction tag(tagName, attrs = {}, ...children) {\n    let el = document.createElement(tagName);\n\n    if (attrs) {\n        for (let attr in attrs) {\n            let val = attrs[attr];\n            let useSetAttr = false;\n\n            if (attr.length > 5 && attr.startsWith(\"html-\")) {\n                useSetAttr = true;\n                attr = attr.substring(5);\n            }\n\n            if (typeof val === \"undefined\") {\n                el.removeAttribute(attr);\n            } else if (\n                // JS property or regular HTML attribute\n                typeof val != \"function\" ||\n                // event\n                (attr.length > 2 && attr.startsWith(\"on\"))\n            ) {\n                if (useSetAttr) {\n                    el.setAttribute(attr, val);\n                } else {\n                    el[attr] = val;\n                }\n            } else {\n                el[watchFuncsSym] = el[watchFuncsSym] || [];\n                el[watchFuncsSym].push(() => {\n                    if (!el) {\n                        return;\n                    }\n\n                    if (useSetAttr) {\n                        el.setAttribute(attr, val(el));\n                    } else {\n                        el[attr] = val(el);\n                    }\n                });\n            }\n        }\n    }\n\n    let customMount = el.onmount;\n    el.onmount = () => {\n        if (el[isMountedSym]) {\n            return;\n        }\n\n        el[isMountedSym] = true;\n\n        if (el[watchFuncsSym]) {\n            el[registeredWatchersSym] = el[registeredWatchersSym] || [];\n            for (let fn of el[watchFuncsSym]) {\n                el[registeredWatchersSym].push(watch(fn));\n            }\n        }\n\n        customMount?.(el);\n    };\n\n    let customUnmount = el.onunmount;\n    el.onunmount = () => {\n        if (!el[isMountedSym]) {\n            return;\n        }\n\n        el[isMountedSym] = false;\n\n        if (el[registeredWatchersSym]) {\n            for (let w of el[registeredWatchersSym]) {\n                w.unwatch();\n            }\n        }\n        el[registeredWatchersSym] = null;\n\n        if (el[cleanupFuncsSym]) {\n            for (let cleanup of el[cleanupFuncsSym]) {\n                cleanup();\n            }\n        }\n        el[cleanupFuncsSym] = null;\n\n        customUnmount?.(el);\n    };\n\n    setChildren(el, children);\n\n    return el;\n}\n\nfunction setChildren(el, children) {\n    children = toArray(children);\n\n    for (let childOrFunc of children) {\n        if (typeof childOrFunc == \"function\") {\n            initChildrenFuncWatcher(el, childOrFunc);\n        } else {\n            let normalized = normalizeNode(childOrFunc);\n            if (Array.isArray(normalized)) {\n                // nested array\n                setChildren(el, normalized);\n            } else if (normalized) {\n                // plain elem\n                el.appendChild(normalized);\n            }\n        }\n    }\n}\n\n// Note: Direct nested reactive functions or direct nested arrays are not supported,\n// aka. childrenFunc must return a single element or plain array of elements.\nfunction initChildrenFuncWatcher(el, childrenFunc) {\n    let endPlaceholder = document.createComment(\"\");\n    el.appendChild(endPlaceholder);\n\n    let oldChildren = [];\n    let oldKeysMap = new Map();\n\n    let elMoveBefore = el.moveBefore || el.insertBefore;\n\n    el[cleanupFuncsSym] = el[cleanupFuncsSym] || [];\n    el[cleanupFuncsSym].push(() => {\n        oldChildren = null;\n        oldKeysMap = null;\n        endPlaceholder = null;\n    });\n\n    el[watchFuncsSym] = el[watchFuncsSym] || [];\n    el[watchFuncsSym].push(() => {\n        if (!el) {\n            return;\n        }\n\n        let newChildren = toArray(childrenFunc(el));\n        let totalNewLength = newChildren.length;\n        let newKeysMap = new Map();\n\n        // no previous children\n        if (!oldChildren?.length) {\n            let fragment = document.createDocumentFragment();\n            for (let i = 0; i < totalNewLength; i++) {\n                newChildren[i] = normalizeNode(newChildren[i]);\n\n                fragment.appendChild(newChildren[i]);\n\n                let rid = newChildren[i].rid;\n                if (typeof rid != \"undefined\") {\n                    if (newKeysMap.has(rid)) {\n                        console.warn(\"Duplicated rid:\", rid, newChildren[i]);\n                    } else {\n                        newKeysMap.set(rid, i);\n                    }\n                }\n            }\n            el.insertBefore(fragment, endPlaceholder);\n            fragment = null;\n\n            oldChildren = newChildren;\n            oldKeysMap = newKeysMap;\n            return;\n        }\n\n        let toMove = [];\n        let toInsert = [];\n        let reused = new Set();\n        let orderedActiveOldIndexes = [];\n\n        // identify new items for reuse or insert\n        for (let newI = 0; newI < totalNewLength; newI++) {\n            newChildren[newI] = normalizeNode(newChildren[newI]);\n\n            let rid = newChildren[newI].rid;\n            if (typeof rid != \"undefined\") {\n                if (newKeysMap.has(rid)) {\n                    console.warn(\"Duplicated rid:\", rid, newChildren[newI]);\n                } else {\n                    newKeysMap.set(rid, newI);\n                }\n\n                // reuse\n                let oldI = oldKeysMap.get(rid);\n                if (oldI >= 0) {\n                    reused.add(oldChildren[oldI]);\n                    newChildren[newI] = oldChildren[oldI];\n                    orderedActiveOldIndexes.push(oldI);\n                    continue;\n                }\n            }\n\n            toInsert.push({\n                child: newChildren[newI],\n                prev: newChildren[newI - 1],\n            });\n        }\n\n        // since the \"reused\" children could be in different order from the original ones,\n        // try to find the longest subsequence that is in the correct order\n        // so that we can minimize the required DOM move operations,\n        // aka. only the elements not found in the resulting subsequence must be reordered\n        let okSubsequence = getLongestSubsequence(orderedActiveOldIndexes);\n        if (orderedActiveOldIndexes.length != okSubsequence.length) {\n            orderedActiveOldIndexes.forEach((idx, i) => {\n                if (!okSubsequence.has(idx)) {\n                    toMove.push({\n                        child: oldChildren[idx],\n                        currentPos: idx,\n                        targetPos: i,\n                    });\n                }\n            });\n        }\n\n        // reorder old children\n        for (let m of toMove) {\n            let before = oldChildren[m.targetPos];\n            arrayMove(oldChildren, m.currentPos, m.targetPos);\n            elMoveBefore.call(el, m.child, before);\n        }\n\n        // insert new children\n        for (let ins of toInsert) {\n            if (ins.prev) {\n                ins.prev.after(ins.child);\n            } else {\n                (oldChildren[0] || endPlaceholder).before(ins.child);\n            }\n        }\n\n        // remove missing old children\n        for (let i = 0; i < oldChildren.length; i++) {\n            if (!reused.has(oldChildren[i])) {\n                oldChildren[i].remove?.();\n            }\n        }\n\n        oldChildren = newChildren;\n        oldKeysMap = newKeysMap;\n\n        // clear to make sure no lingering references remain\n        newChildren = null;\n        newKeysMap = null;\n        reused = null;\n        toMove = null;\n        toInsert = null;\n    });\n}\n\n// Returns the elements of the Longest Increasing Subsequence (LIS) for an array of indexes.\n//\n// Note that the returned sequence is in reverse order but for our case\n// it doesn't matter because we are interested only in the elements.\n//\n// For more details and visual representation of the the algorithm, please check:\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms\nfunction getLongestSubsequence(arr) {\n    let ends = [];\n    let predecessors = [];\n\n    for (let i = 0; i < arr.length; i++) {\n        let current = arr[i];\n\n        let low = 0;\n        let mid = 0;\n        let high = ends.length;\n        while (low < high) {\n            mid = Math.floor((low + high) / 2);\n            if (arr[ends[mid]] >= current) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        if (low > 0) {\n            predecessors[i] = ends[low - 1];\n        }\n\n        ends[low] = i;\n    }\n\n    let result = new Set();\n\n    // reconstruct the LIS elements via backtracking\n    let lastIdx = ends[ends.length - 1];\n    while (typeof lastIdx != \"undefined\") {\n        result.add(arr[lastIdx]);\n        lastIdx = predecessors[lastIdx];\n    }\n\n    return result;\n}\n\nfunction arrayMove(arr, from, to) {\n    if (from == to) {\n        return arr;\n    }\n\n    let dir = from > to ? -1 : 1;\n    let target = arr[from];\n\n    for (let i = from; i != to; i += dir) {\n        arr[i] = arr[i + dir];\n    }\n\n    arr[to] = target;\n}\n\nfunction toArray(val) {\n    if (typeof val == \"undefined\" || val === null) {\n        return [];\n    }\n\n    return Array.isArray(val) ? val : [val];\n}\n\nfunction normalizeNode(child) {\n    // wrap as TextNode so that it can be \"tracked\" and used with appendChild or other similar methods\n    if (typeof child == \"string\" || typeof child == \"number\" || typeof child == \"boolean\") {\n        let childNode = document.createTextNode(child);\n        childNode.rid = child;\n        return childNode;\n    }\n\n    // in case child is DOM Proxy element/array loaded from a store object\n    if (typeof child?.__raw != \"undefined\") {\n        return child.__raw\n    }\n\n    return child;\n}\n","/**\n * @callback routeHandler\n * @param {{params:Object.<string,string>, query:Object.<string,string[]>, path:string, regex:string, pattern:string, handler:Function}} route\n * @return {Function|void} Optional destroy function.\n */\n/**\n * Router set up a hash-based client-side router by loading the\n * provided routes configuration and listens for hash navigation changes.\n *\n * `routes` is a key-value object where:\n * - the key must be a string path such as \"#/a/b/{someParam}\"\n * - value is a route handler function that executes every time the page hash matches with the route's path.\n *     The route handler can return a \"destroy\" function that will be invoked when navigating away from that route.\n *\n * Note that by default it expects to have at least one \"#/\" route that will be\n * also used as fallback in case the user navigate to a page that is not defined.\n *\n * Example:\n *\n * ```js\n * router({\n *     \"#/\": (route) => {\n *         document.getElementById(app).replaceChildren(\n *             t.div({ textContent: \"Homepage!\"})\n *         )\n *     },\n *     \"#/users/{id}\": (route) => {\n *         document.getElementById(app).replaceChildren(\n *             t.div({ textContent: \"User \" + route.params.id })\n *         )\n *     },\n * })\n * ```\n *\n * @param {Object.<string, routeHandler>} routes\n * @param {Object} [options]\n * @param {string} [options.fallbackPath]\n * @param {boolean} [options.transition]\n */\nexport function router(routes, options = { fallbackPath: \"#/\", transition: true }) {\n    let defs = prepareRoutes(routes);\n\n    let prevDestroy;\n\n    let onHashChange = () => {\n        let path = window.location.hash;\n\n        let route = findActiveRoute(defs, path);\n        if (!route) {\n            if (options.fallbackPath != path) {\n                window.location.hash = options.fallbackPath;\n                return\n            }\n\n            console.warn(\"missing route:\", path);\n            return;\n        }\n\n        let navigate = async () => {\n            try {\n                await prevDestroy?.();\n                prevDestroy = await route.handler(route);\n            } catch (err) {\n                console.warn(\"route navigation failed:\", err);\n            }\n        };\n\n        if (options.transition && document.startViewTransition) {\n            document.startViewTransition(navigate);\n        } else {\n            navigate();\n        }\n    };\n\n    window.addEventListener(\"hashchange\", onHashChange);\n\n    onHashChange();\n}\n\nfunction findActiveRoute(defs, path) {\n    for (let def of defs) {\n        let match = path.match(def.regex);\n        if (!match) {\n            continue;\n        }\n\n        // extract query params (the value is always stored as array)\n        let query = {};\n        let rawQuery = path.split(\"?\")?.[1];\n        if (rawQuery) {\n            let searchParams = new URLSearchParams(rawQuery);\n            for (let [key, value] of searchParams.entries()) {\n                if (!Array.isArray(query[key])) {\n                    query[key] = query[key] ? [query[key]] : [];\n                }\n                query[key].push(value);\n            }\n        }\n\n        return Object.assign(\n            {\n                path: path,\n                query: query,\n                params: match.groups || {},\n            },\n            def,\n        );\n    }\n}\n\nfunction prepareRoutes(routes) {\n    let defs = [];\n\n    for (let path in routes) {\n        let parts = path.split(\"/\");\n        for (let i in parts) {\n            if (\n                parts[i].length > 2 &&\n                parts[i].startsWith(\"{\") &&\n                parts[i].endsWith(\"}\")\n            ) {\n                // param\n                parts[i] = \"(?<\" + parts[i].substring(1, parts[i].length - 1) + \">[^\\\\/#?]+)\";\n            } else {\n                // regular path segment\n                parts[i] = RegExp.escape(parts[i]);\n            }\n        }\n\n        defs.push({\n            regex: new RegExp(\"^\" + parts.join(\"\\\\/\") + \"(?:[\\?\\#].*)?$\"),\n            pattern: path,\n            handler: routes[path],\n        });\n    }\n\n    return defs;\n}\n"],"mappings":"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"}